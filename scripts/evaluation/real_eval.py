import argparse
import os
import glob
import numpy as np
import pandas as pd
from datetime import datetime

# Optional dependencies
try:
    from mcap.reader import make_reader
    from mcap_ros2.decoder import DecoderFactory
except ImportError:
    pass # Handled in main or usage

class RobustVelocityEstimator:
    """
    Robust Velocity Estimator using Sensor Fusion (Leg Odometry + IMU)
    """
    def __init__(self):
        self.alpha = 0.95  # Filter weight
        self.dt = 0.002    # Sample time (approx)

    def compute_velocity(self, data):
        """Takes a data dictionary and returns an estimated velocity (vx) array."""
        print("[INFO] Computing velocity from Sensor Fusion (Leg Odom + IMU)...")
        
        # Extract data
        dof_vel = data["dof_vel"]
        dof_pos = data["dof_pos"]
        
        # Robust key access
        if "foot_force" in data:
            foot_force = data["foot_force"]
        else:
            foot_force = np.zeros((len(dof_vel), 4))

        if "dof_torque" in data:
            dof_torque = data["dof_torque"]
        else:
            dof_torque = None

        if "base_acc" in data:
            acc_local = data["base_acc"]
        elif "base_acc_0" in data:
            acc_local = np.array([data[f"base_acc_{i}"] for i in range(3)]).T
        else:
            acc_local = np.zeros((len(dof_vel), 3))
            
        if "base_quat" in data:
            quat = data["base_quat"]
        elif "base_quat_0" in data:
            quat = np.array([data[f"base_quat_{i}"] for i in range(4)]).T
        else:
            quat = np.array([[1,0,0,0]]*len(dof_vel))
        
        # 기구학 파라미터 (Go2)
        L2, L3 = 0.213, 0.213 
        
        estimated_vx = []
        current_v = 0.0
        
        for i in range(len(dof_vel)):
            # 1. Leg Odometry (지면에 닿은 다리 기준 속도 역산)
            leg_vs = []
            for leg in range(4):
                is_contact = False
                # Force Check
                if foot_force[i, leg] > 15.0: 
                    is_contact = True
                
                # Torque Check (Fallback)
                if dof_torque is not None:
                    idx = leg * 3
                    # Thigh + Calf torque sum
                    t_sum = abs(dof_torque[i, idx+1]) + abs(dof_torque[i, idx+2])
                    if t_sum > 5.0:
                        is_contact = True

                if is_contact:
                    # 각 다리의 Hip, Thigh, Calf 인덱스
                    idx = leg * 3
                    q_thigh = dof_pos[i, idx+1]
                    q_calf = dof_pos[i, idx+2]
                    dq_thigh = dof_vel[i, idx+1]
                    dq_calf = dof_vel[i, idx+2]
                    
                    # Forward Kinematics Derivative (v_x only)
                    # v_foot = J * dq -> v_body = -v_foot
                    v_foot_x = (L2 * np.cos(q_thigh) * dq_thigh + 
                                L3 * np.cos(q_thigh + q_calf) * (dq_thigh + dq_calf))
                    leg_vs.append(-v_foot_x)
            
            v_leg = np.mean(leg_vs) if leg_vs else 0.0
            
            # 2. IMU Acceleration (World Frame 변환 생략하고 x축 근사 사용)
            # 엄밀하게는 쿼터니언 회전 필요하지만, 평지 주행 가정 시 ax 그대로 사용 가능
            ax = acc_local[i, 0]
            
            # 3. Sensor Fusion (Complementary)
            if not leg_vs: # 공중
                v_pred = current_v + ax * self.dt
                current_v = v_pred * 0.98 # Decay
            else:
                v_pred = current_v + ax * self.dt
                current_v = self.alpha * v_pred + (1 - self.alpha) * v_leg
                
            estimated_vx.append(current_v)
            
        return np.array(estimated_vx) 


class CsvLogLoader:
    """Loads real-world robot logs from CSV files generated by logger_node.py (multiple files per run)."""
    
    def __init__(self, file_path_pattern):
        # file_path_pattern 예: logs/real_log_2026-01-06_13-39-47 (뒤에 _cat.csv는 자동 매칭)
        self.run_prefix = file_path_pattern.replace(".csv", "").split("_base")[0] # base, imu 등 접미사 제거 시도
        
        # 만약 사용자가 '..._base.csv'를 입력했다면 prefix 추출 로직 개선
        if "_base" in self.run_prefix: self.run_prefix = self.run_prefix.replace("_base", "")
        if "_imu" in self.run_prefix: self.run_prefix = self.run_prefix.replace("_imu", "")
        # ... 기타 카테고리
        
    def load(self):
        # 1. 파일 세트 찾기 (base, imu, joint, ...)
        # 로거 파일명: real_log_{YYYY-MM-DD_HH-MM-SS}_{CATEGORY}.csv
        
        # 파일 존재 확인 (base 파일 기준)
        base_file = f"{self.run_prefix}_base.csv"
        if not os.path.exists(base_file):
            # 구형(단일 파일) 로그 호환성 체크
            if os.path.exists(f"{self.run_prefix}.csv"):
                print("[INFO] Detected legacy single-file CSV.")
                return self._load_legacy(f"{self.run_prefix}.csv")
            else:
                raise FileNotFoundError(f"Base log file not found: {base_file}")
                
        print(f"[INFO] Parsing Multi-File CSV Set: {self.run_prefix}_*.csv")

        # 각 파일 로드
        try:
           df_base = pd.read_csv(f"{self.run_prefix}_base.csv")
           df_imu = pd.read_csv(f"{self.run_prefix}_imu.csv")
           df_joint = pd.read_csv(f"{self.run_prefix}_joint.csv")
           df_bms = pd.read_csv(f"{self.run_prefix}_bms.csv")
           df_foot = pd.read_csv(f"{self.run_prefix}_foot.csv")
           
        except FileNotFoundError as e:
            raise FileNotFoundError(f"One of the required log files is missing: {e}")

        # 병합 (타임스탬프 기준)
        # 로거가 timestamp를 모두 동일하게 찍었다면 단순 concat(axis=1) 가능하지만,
        # 안전하게 pandas merge 사용 (timestamp 기준) 또는 인덱스 기준
        
        # 여기서는 로거가 같은 주기로 동기화해서 찍으므로 행 개수가 같다고 가정하고 
        # 단순 결합 (단, timestamp 정렬 확인 필요)
        
        # 데이터 길이 검증
        min_len = min(len(df_base), len(df_imu), len(df_joint), len(df_foot))
        print(f"[DEBUG] CSV Lengths - Base: {len(df_base)}, IMU: {len(df_imu)}, Joint: {len(df_joint)}")
        
        # min_len에 맞춰 자르기
        df_base = df_base.iloc[:min_len]
        df_imu = df_imu.iloc[:min_len]
        df_joint = df_joint.iloc[:min_len]
        df_bms = df_bms.iloc[:min_len]
        df_foot = df_foot.iloc[:min_len]
        
        data = {
            "timestamp": df_base["timestamp"].values,
            
            # Base (Command & Est Velocity)
            "command_vel": df_base[["cmd_vx", "cmd_vy", "cmd_wz"]].values, # [vx, vy, wz]
            "base_lin_vel": df_base[["vx", "vy", "vz"]].values,          # Est V
            "est_vx_logger": df_base[["est_vx", "est_vy", "est_vz"]].values, # Logger's internal estimator (optional usage)

            # IMU
            "base_ang_vel": df_imu[["wx", "wy", "wz"]].values,
            "base_acc": df_imu[["ax", "ay", "az"]].values,
            "rpy": df_imu[["roll", "pitch", "yaw"]].values,
            "base_quat": df_imu[["quat_w", "quat_x", "quat_y", "quat_z"]].values,

            # Joint
            "dof_pos": df_joint[[f"q_{i}" for i in range(12)]].values,
            "dof_vel": df_joint[[f"dq_{i}" for i in range(12)]].values,
            "dof_torque": df_joint[[f"tau_{i}" for i in range(12)]].values,
            "motor_temp": df_joint[[f"temp_{i}" for i in range(12)]].values,

            # Foot
            "foot_force": df_foot[[f"force_{i}" for i in range(4)]].values,
            
            # BMS
            "bms_power": df_bms["power"].values
        }

        return data

    def _load_legacy(self, path):
         # 기존 단일 파일 로드 로직 (하위 호환성)
         # 편의상 pandas로 다시 짬
         df = pd.read_csv(path)
         print("[WARN] Legacy single-file loader detected.")
         
         # 간단 매핑 시도 (컬럼명이 다를 수 있어 주의)
         # 필요한 경우 여기에 예전 컬럼 매핑 로직 추가
         return None


class RosBagLoader:
    """Loads real-world robot logs from ROS2 MCAP files."""
    
    def __init__(self, bag_path):
        self.bag_path = bag_path

    def load(self):
        """Parses standard ROS2 topics from the bag file."""
        if not os.path.exists(self.bag_path):
            raise FileNotFoundError(f"Bag file not found: {self.bag_path}")

        print(f"[INFO] Parsing ROS Bag: {self.bag_path}")
        
        data = {
            "timestamp": [],
            "base_lin_vel": [],
            "dof_pos": [],
            "dof_vel": [],
            "dof_torque": [],
            "command_vel": []
        }
        
        # Temporary storage for synchronization
        # We assume messages are written in blocks with same timestamp or close enough
        # We trigger a data point when we receive JointState
        last_cmd = [0.0, 0.0, 0.0] # vx, vy, wz
        last_odom_vel = [0.0, 0.0, 0.0] # vx, vy, vz
        
        with open(self.bag_path, "rb") as f:
            reader = make_reader(f, decoder_factories=[DecoderFactory()])
            
            start_time = None
            
            # Topics to read
            topics = ["/joint_states", "/odom", "/cmd_vel"]
            
            for schema, channel, message in reader.iter_decoded_messages(topics=topics):
                topic = channel.topic
                
                # 1. Command Velocity
                if topic == "/cmd_vel":
                    last_cmd = [message.linear.x, message.linear.y, message.angular.z]
                    
                # 2. Odometry (Base Velocity)
                elif topic == "/odom":
                    last_odom_vel = [
                        message.twist.twist.linear.x,
                        message.twist.twist.linear.y,
                        message.twist.twist.linear.z
                    ]

                # 4. Joint States (Trigger)
                elif topic == "/joint_states":
                    # Extract timestamp
                    t = message.header.stamp.sec + message.header.stamp.nanosec * 1e-9
                    
                    if start_time is None:
                        start_time = t
                    
                    # Joint Data
                    # Ensure order is correct (FL, FR, RL, RR) or just take as is if logger preserves order
                    # go2_logger writes in 0-11 order
                    q = message.position
                    dq = message.velocity
                    tau = message.effort
                    
                    if len(q) != 12:
                        continue

                    data["timestamp"].append(t - start_time)
                    data["dof_pos"].append(q)
                    data["dof_vel"].append(dq)
                    data["dof_torque"].append(tau)
                    data["base_lin_vel"].append(last_odom_vel)
                    data["command_vel"].append(last_cmd)

        # Convert to numpy arrays
        for key in data:
            data[key] = np.array(data[key])
            
        print(f"[INFO] Loaded {len(data['timestamp'])} frames from Real Log.")
        return data


class RealPerformanceEvaluator:
    """Evaluates Real-world robot performance based on internal Ground Truth."""
    
    def __init__(self, real_data):
        self.real = real_data

    def evaluate(self):
        print("[INFO] Evaluating Real Robot Performance...")

        # ---------------------------------------------------------
        # 우선순위 1: High Level Velocity (Sensor/SportMode)
        real_vel_vec = self.real["base_lin_vel"]
        speed_raw = np.linalg.norm(real_vel_vec[:, :2], axis=1)
        mean_speed = np.mean(speed_raw)
        
        velocity_source = "Unknown"
        final_speed_data = speed_raw
        
        if mean_speed > 0.01:
            velocity_source = "High Level (Sensor)"
            final_speed_data = speed_raw
            
        else:
            # 우선순위 2: Logged Estimated Velocity (est_vx 컬럼이 있는 경우)
            if "est_vx" in self.real:
                velocity_source = "Logged Estimate (Online)"
                est_vx = self.real["est_vx"]
                est_vy = self.real["est_vy"]
                final_speed_data = np.sqrt(est_vx**2 + est_vy**2)
                
            # 우선순위 3: Post-Calculated Estimate (직접 계산)
            else:
                velocity_source = "Computed Estimate (Offline)"
                estimator = RobustVelocityEstimator()
                # self.real 딕셔너리를 넘겨주기 위해 numpy array로 변환된 상태인지 확인 필요
                # Loader에서 이미 numpy로 변환했으므로 그대로 전달
                est_vx = estimator.compute_velocity(self.real)
                final_speed_data = np.abs(est_vx) # 전진 속도 크기

        print(f"[INFO] Selected Velocity Source: {velocity_source}")
        # ---------------------------------------------------------

        # 1. Velocity Tracking (GT: cmd_vel)
        # cmd_vel: [vx, vy, wz]
        # base_lin_vel: [vx, vy, vz]
        # base_ang_vel: [wx, wy, wz]
        
        cmd_vx = self.real["command_vel"][:, 0]
        cmd_vy = self.real["command_vel"][:, 1]
        cmd_wz = self.real["command_vel"][:, 2]
        
        real_vx = self.real["base_lin_vel"][:, 0]
        real_vy = self.real["base_lin_vel"][:, 1]
        
        # Check if base_ang_vel exists and has data
        if "base_ang_vel" in self.real and len(self.real["base_ang_vel"]) > 0:
            real_wz = self.real["base_ang_vel"][:, 2]
        else:
            real_wz = np.zeros_like(cmd_wz) # Fallback if not available
            
        # RMSE Calculation
        rmse_vx = np.sqrt(np.mean((cmd_vx - real_vx)**2))
        rmse_vy = np.sqrt(np.mean((cmd_vy - real_vy)**2))
        rmse_wz = np.sqrt(np.mean((cmd_wz - real_wz)**2))
        
        # 2. Stability (GT: 0.0 rad for Roll/Pitch)
        # RPY: [roll, pitch, yaw]
        if "rpy" in self.real and len(self.real["rpy"]) > 0:
            roll = self.real["rpy"][:, 0]
            pitch = self.real["rpy"][:, 1]
            
            roll_mean = np.mean(roll)
            roll_std = np.std(roll)
            pitch_mean = np.mean(pitch)
            pitch_std = np.std(pitch)
        else:
            roll_mean, roll_std = 0.0, 0.0
            pitch_mean, pitch_std = 0.0, 0.0
            
        # 3. Energy Efficiency (CoT with Selected Speed)
        BASELINE_POWER = 53.8
        ROBOT_MASS = 15.0
        GRAVITY = 9.81
        
        avg_power = 0.0
        std_power = 0.0
        cot_val = 0.0
        
        if "bms_power" in self.real and len(self.real["bms_power"]) > 0:
            # Masking: 실제 로봇이 움직이는 구간 (Selected Speed 기준)
            speed_sensor = final_speed_data
            is_active = speed_sensor > 0.01
            
            if np.sum(is_active) > 0:
                active_power = self.real["bms_power"][is_active]
                active_speed = speed_sensor[is_active] # Selected 속도 사용
                
                avg_power = np.mean(active_power)
                std_power = np.std(active_power)
                
                # [Modified] CoT Calculation: Filter for actual walking (speed > 0.2 m/s)
                # to exclude standing/stuck phases which inflate CoT.
                is_walking = active_speed > 0.2
                if np.sum(is_walking) > 10: # Minimum frames to be valid
                    walking_power = active_power[is_walking]
                    walking_speed = active_speed[is_walking]
                    cot_val = np.mean(walking_power) / (ROBOT_MASS * GRAVITY * np.mean(walking_speed))
                    print(f"[INFO] CoT calculated using {np.sum(is_walking)} frames (Speed > 0.2 m/s)")
                else:
                    # Fallback to average if never reached 0.2 m/s
                    avg_speed_val = np.mean(active_speed)
                    if avg_speed_val > 0.01:
                        cot_val = avg_power / (ROBOT_MASS * GRAVITY * avg_speed_val)
                    else:
                        cot_val = 0.0
                    
        cot_ratio = avg_power / BASELINE_POWER if BASELINE_POWER > 0 else 0.0
            
        # 4. Smoothness (Jitter)
        # We define Jitter as the mean absolute change in torque between time steps.
        # Lower is smoother.
        if "dof_torque" in self.real and len(self.real["dof_torque"]) > 0:
            # Calculate diff along time axis (axis 0)
            torque_diff = np.diff(self.real["dof_torque"], axis=0)
            # Mean of absolute differences across all joints and time steps
            torque_jitter = np.mean(np.abs(torque_diff))
        else:
            torque_jitter = 0.0

        # 5. Thermal Efficiency (Max Temp)
        max_temp = 0.0
        if "motor_temp" in self.real and len(self.real["motor_temp"]) > 0:
            max_temp = np.max(self.real["motor_temp"])
        
        return {
            "rmse_vx": rmse_vx,
            "rmse_vy": rmse_vy,
            "rmse_wz": rmse_wz,
            "roll_mean": roll_mean,
            "roll_std": roll_std,
            "pitch_mean": pitch_mean,
            "pitch_std": pitch_std,
            "avg_power": avg_power,
            "std_power": std_power,
            "power_ratio": cot_ratio,
            "cot": cot_val,
            "vel_source": velocity_source,
            "torque_jitter": torque_jitter,
            "max_temp": max_temp
        }

    def generate_report(self, metrics):
        print("\n" + "="*50)
        print("REAL ROBOT PERFORMANCE REPORT (Internal GT)")
        print("="*50)
        print("1. Velocity Tracking (GT: Time-variant cmd_vel)")
        print(f"   Vx RMSE: {metrics['rmse_vx']:.4f} m/s")
        print(f"   Vy RMSE: {metrics['rmse_vy']:.4f} m/s")
        print(f"   Wz RMSE: {metrics['rmse_wz']:.4f} rad/s")
        print("\n2. Stability (GT: 0.0 rad)")
        print(f"   Roll  - Mean (Bias): {metrics['roll_mean']:.4f}, Std: {metrics['roll_std']:.4f}")
        print(f"   Pitch - Mean (Bias): {metrics['pitch_mean']:.4f}, Std: {metrics['pitch_std']:.4f}")
        if abs(metrics['pitch_mean']) > 0.03:
            print(f"   [WARN] Pitch bias > 0.03 rad detected. Calibration recommended.")
        print("\n3. Energy Efficiency (Baseline: 53.8 W)")
        print(f"   Avg Power: {metrics['avg_power']:.2f} W (+/- {metrics['std_power']:.2f})")
        print(f"   Ratio to Baseline: {metrics['power_ratio']:.2f}x")
        print(f"   Velocity Source: {metrics.get('vel_source', 'Unknown')}")
        print(f"   Calculated CoT:  {metrics.get('cot', 0.0):.4f}")
        print("\n4. Control Smoothness (Jitter)")
        print(f"   Torque Jitter: {metrics['torque_jitter']:.4f} Nm/step")
        print(f"   (Lower is better. High values indicate vibration/noise)")
        print("\n5. Thermal & Safety")
        print(f"   Max Motor Temp: {metrics['max_temp']:.1f} °C")
        print(f"   Mean Motor Temp: {np.mean(self.real['motor_temp']):.1f} °C")
        if metrics['max_temp'] > 85.0:
             print(f"   [CRITICAL] Motor Overheat Detected (> 85°C)!")
        print("="*50 + "\n")

        # --- CSV 저장 ---
        today_str = datetime.now().strftime('%Y-%m-%d')
        csv_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'sim2real_reports')
        os.makedirs(csv_dir, exist_ok=True)
        csv_path = os.path.join(csv_dir, f"real_eval_report_{today_str}.csv")
        file_exists = os.path.isfile(csv_path)
        fieldnames = [
            'Date', 'Vx_RMSE', 'Vy_RMSE', 'Wz_RMSE',
            'Roll_Mean', 'Roll_Std', 'Pitch_Mean', 'Pitch_Std',
            'Avg_Power', 'Std_Power', 'Power_Ratio', 'CoT', 'Velocity_Source', 'Torque_Jitter',
            'Max_Temp'
        ]
        row = {
            'Date': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            'Vx_RMSE': f"{metrics['rmse_vx']:.4f}",
            'Vy_RMSE': f"{metrics['rmse_vy']:.4f}",
            'Wz_RMSE': f"{metrics['rmse_wz']:.4f}",
            'Roll_Mean': f"{metrics['roll_mean']:.4f}",
            'Roll_Std': f"{metrics['roll_std']:.4f}",
            'Pitch_Mean': f"{metrics['pitch_mean']:.4f}",
            'Pitch_Std': f"{metrics['pitch_std']:.4f}",
            'Avg_Power': f"{metrics['avg_power']:.2f}",
            'Std_Power': f"{metrics['std_power']:.2f}",
            'Power_Ratio': f"{metrics['power_ratio']:.2f}",
            'CoT': f"{metrics.get('cot', 0.0):.4f}",
            'Velocity_Source': metrics.get('vel_source', 'Unknown'),
            'Torque_Jitter': f"{metrics['torque_jitter']:.4f}",
            'Max_Temp': f"{metrics['max_temp']:.1f}"
        }
        import csv
        with open(csv_path, 'a', newline='') as csvfile:
            writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
            if not file_exists:
                writer.writeheader()
            writer.writerow(row)
        print(f"[INFO] Report appended to {csv_path}")

def main():
    parser = argparse.ArgumentParser(description="Real Robot Performance Evaluator")
    parser.add_argument("log_dir", type=str, nargs='?', default="logs", help="Directory containing logs (default: logs)")
    parser.add_argument("--file", type=str, default=None, help="Specific file path (optional)")
    
    args = parser.parse_args()
    
    target_path = None
    
    # 1. 특정 파일이 지정된 경우
    if args.file:
        target_path = args.file
    
    # 2. 디렉토리에서 최신 로그 자동 검색
    else:
        log_dir = args.log_dir
        if not os.path.exists(log_dir):
            print(f"[ERROR] Log directory not found: {log_dir}")
            return

        # CSV (base) 및 MCAP 검색
        csv_candidates = glob.glob(os.path.join(log_dir, "*_base.csv"))
        mcap_candidates = glob.glob(os.path.join(log_dir, "*.mcap"))
        
        candidates = []
        candidates.extend(csv_candidates)
        candidates.extend(mcap_candidates)
        
        if not candidates:
            print(f"[ERROR] No valid log files (csv or mcap) found in {log_dir}")
            return
            
        # 최신 수정일 기준 정렬
        candidates.sort(key=os.path.getmtime, reverse=True)
        target_path = candidates[0]
        print(f"[INFO] Automatically selected latest log: {target_path}")

    # Load Real Data
    if target_path.endswith('.csv'):
        real_loader = CsvLogLoader(target_path)
    elif target_path.endswith('.mcap'):
        real_loader = RosBagLoader(target_path)
    else:
        print(f"[ERROR] Unsupported file format: {target_path}. Use .csv or .mcap")
        return

    try:
        real_data = real_loader.load()
    except Exception as e:
        print(f"[ERROR] Failed to load Real data: {e}")
        return

    # Evaluate Real Performance (Internal GT)
    real_evaluator = RealPerformanceEvaluator(real_data)
    real_metrics = real_evaluator.evaluate()
    real_evaluator.generate_report(real_metrics)

if __name__ == "__main__":
    main()
