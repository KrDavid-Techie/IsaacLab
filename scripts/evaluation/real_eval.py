import argparse
import os
import sys
import csv
import numpy as np
from datetime import datetime

# Optional dependencies
try:
    from mcap.reader import make_reader
    from mcap_ros2.decoder import DecoderFactory
except ImportError:
    pass # Handled in main or usage

class CsvLogLoader:
    """Loads real-world robot logs from CSV files generated by logger_node.py."""
    
    def __init__(self, file_path):
        self.file_path = file_path

    def load(self):
        if not os.path.exists(self.file_path):
            raise FileNotFoundError(f"CSV log file not found: {self.file_path}")
            
        print(f"[INFO] Parsing CSV Log: {self.file_path}")
        
        data = {
            "timestamp": [],
            "base_lin_vel": [],
            "base_ang_vel": [],
            "dof_pos": [],
            "dof_vel": [],
            "dof_torque": [],
            "command_vel": [],
            "bms_power": [],
            "rpy": []
        }
        
        with open(self.file_path, 'r') as f:
            reader = csv.DictReader(f)
            for row in reader:
                try:
                    # Timestamp
                    data["timestamp"].append(float(row['timestamp']))
                    
                    # Command Velocity [vx, vy, wz]
                    data["command_vel"].append([
                        float(row['cmd_vel_0']), 
                        float(row['cmd_vel_1']), 
                        float(row['cmd_vel_2'])
                    ])
                    
                    # Base Linear Velocity [vx, vy, vz]
                    data["base_lin_vel"].append([
                        float(row['base_lin_vel_0']), 
                        float(row['base_lin_vel_1']), 
                        float(row['base_lin_vel_2'])
                    ])

                    # Base Angular Velocity [wx, wy, wz]
                    if 'base_ang_vel_0' in row:
                        data["base_ang_vel"].append([
                            float(row['base_ang_vel_0']), 
                            float(row['base_ang_vel_1']), 
                            float(row['base_ang_vel_2'])
                        ])
                    else:
                        data["base_ang_vel"].append([0.0, 0.0, 0.0])
                    
                    # Joint States (12 DOF)
                    data["dof_pos"].append([float(row[f'dof_pos_{i}']) for i in range(12)])
                    data["dof_vel"].append([float(row[f'dof_vel_{i}']) for i in range(12)])
                    data["dof_torque"].append([float(row[f'dof_torque_{i}']) for i in range(12)])
                    
                    # RPY
                    if 'rpy_roll' in row:
                        data["rpy"].append([
                            float(row['rpy_roll']),
                            float(row['rpy_pitch']),
                            float(row['rpy_yaw'])
                        ])
                    else:
                        data["rpy"].append([0.0, 0.0, 0.0])

                    # BMS Power (if available)
                    if 'power' in row:
                        data["bms_power"].append(float(row['power']))
                    elif 'bms_voltage' in row and 'bms_current' in row:
                        data["bms_power"].append(float(row['bms_voltage']) * float(row['bms_current']))
                    else:
                        data["bms_power"].append(0.0)
                        
                except ValueError:
                    continue # Skip malformed rows

        # Convert to numpy arrays
        for key in data:
            data[key] = np.array(data[key])
            
        print(f"[INFO] Loaded {len(data['timestamp'])} frames from CSV Log.")
        return data


class RosBagLoader:
    """Loads real-world robot logs from ROS2 MCAP files."""
    
    def __init__(self, bag_path):
        self.bag_path = bag_path

    def load(self):
        """Parses standard ROS2 topics from the bag file."""
        if not os.path.exists(self.bag_path):
            raise FileNotFoundError(f"Bag file not found: {self.bag_path}")

        print(f"[INFO] Parsing ROS Bag: {self.bag_path}")
        
        data = {
            "timestamp": [],
            "base_lin_vel": [],
            "dof_pos": [],
            "dof_vel": [],
            "dof_torque": [],
            "command_vel": []
        }
        
        # Temporary storage for synchronization
        # We assume messages are written in blocks with same timestamp or close enough
        # We trigger a data point when we receive JointState
        last_cmd = [0.0, 0.0, 0.0] # vx, vy, wz
        last_odom_vel = [0.0, 0.0, 0.0] # vx, vy, vz
        
        with open(self.bag_path, "rb") as f:
            reader = make_reader(f, decoder_factories=[DecoderFactory()])
            
            start_time = None
            
            # Topics to read
            topics = ["/joint_states", "/odom", "/cmd_vel"]
            
            for schema, channel, message in reader.iter_decoded_messages(topics=topics):
                topic = channel.topic
                
                # 1. Command Velocity
                if topic == "/cmd_vel":
                    last_cmd = [message.linear.x, message.linear.y, message.angular.z]
                    
                # 2. Odometry (Base Velocity)
                elif topic == "/odom":
                    last_odom_vel = [
                        message.twist.twist.linear.x,
                        message.twist.twist.linear.y,
                        message.twist.twist.linear.z
                    ]
                    
                # 3. Joint States (Trigger)
                elif topic == "/joint_states":
                    # Extract timestamp
                    t = message.header.stamp.sec + message.header.stamp.nanosec * 1e-9
                    
                    if start_time is None:
                        start_time = t
                    
                    # Joint Data
                    # Ensure order is correct (FL, FR, RL, RR) or just take as is if logger preserves order
                    # go2_logger writes in 0-11 order
                    q = message.position
                    dq = message.velocity
                    tau = message.effort
                    
                    if len(q) != 12:
                        continue

                    data["timestamp"].append(t - start_time)
                    data["dof_pos"].append(q)
                    data["dof_vel"].append(dq)
                    data["dof_torque"].append(tau)
                    data["base_lin_vel"].append(last_odom_vel)
                    data["command_vel"].append(last_cmd)

        # Convert to numpy arrays
        for key in data:
            data[key] = np.array(data[key])
            
        print(f"[INFO] Loaded {len(data['timestamp'])} frames from Real Log.")
        return data


class RealPerformanceEvaluator:
    """Evaluates Real-world robot performance based on internal Ground Truth."""
    
    def __init__(self, real_data):
        self.real = real_data

    def evaluate(self):
        print("[INFO] Evaluating Real Robot Performance...")
        
        # 1. Velocity Tracking (GT: cmd_vel)
        # cmd_vel: [vx, vy, wz]
        # base_lin_vel: [vx, vy, vz]
        # base_ang_vel: [wx, wy, wz]
        
        cmd_vx = self.real["command_vel"][:, 0]
        cmd_vy = self.real["command_vel"][:, 1]
        cmd_wz = self.real["command_vel"][:, 2]
        
        real_vx = self.real["base_lin_vel"][:, 0]
        real_vy = self.real["base_lin_vel"][:, 1]
        
        # Check if base_ang_vel exists and has data
        if "base_ang_vel" in self.real and len(self.real["base_ang_vel"]) > 0:
            real_wz = self.real["base_ang_vel"][:, 2]
        else:
            real_wz = np.zeros_like(cmd_wz) # Fallback if not available
            
        # RMSE Calculation
        rmse_vx = np.sqrt(np.mean((cmd_vx - real_vx)**2))
        rmse_vy = np.sqrt(np.mean((cmd_vy - real_vy)**2))
        rmse_wz = np.sqrt(np.mean((cmd_wz - real_wz)**2))
        
        # 2. Stability (GT: 0.0 rad for Roll/Pitch)
        # RPY: [roll, pitch, yaw]
        if "rpy" in self.real and len(self.real["rpy"]) > 0:
            roll = self.real["rpy"][:, 0]
            pitch = self.real["rpy"][:, 1]
            
            roll_mean = np.mean(roll)
            roll_std = np.std(roll)
            pitch_mean = np.mean(pitch)
            pitch_std = np.std(pitch)
        else:
            roll_mean, roll_std = 0.0, 0.0
            pitch_mean, pitch_std = 0.0, 0.0
            
        # 3. Energy (Baseline: 53.8 W)
        BASELINE_POWER = 53.8
        
        if "bms_power" in self.real and len(self.real["bms_power"]) > 0:
            power = self.real["bms_power"]
            avg_power = np.mean(power)
            std_power = np.std(power)
            cot_ratio = avg_power / BASELINE_POWER if BASELINE_POWER > 0 else 0.0
        else:
            avg_power, std_power, cot_ratio = 0.0, 0.0, 0.0
            
        # 4. Smoothness (Jitter)
        # We define Jitter as the mean absolute change in torque between time steps.
        # Lower is smoother.
        if "dof_torque" in self.real and len(self.real["dof_torque"]) > 0:
            # Calculate diff along time axis (axis 0)
            torque_diff = np.diff(self.real["dof_torque"], axis=0)
            # Mean of absolute differences across all joints and time steps
            torque_jitter = np.mean(np.abs(torque_diff))
        else:
            torque_jitter = 0.0

        return {
            "rmse_vx": rmse_vx,
            "rmse_vy": rmse_vy,
            "rmse_wz": rmse_wz,
            "roll_mean": roll_mean,
            "roll_std": roll_std,
            "pitch_mean": pitch_mean,
            "pitch_std": pitch_std,
            "avg_power": avg_power,
            "std_power": std_power,
            "power_ratio": cot_ratio,
            "torque_jitter": torque_jitter
        }

    def generate_report(self, metrics):
        print("\n" + "="*50)
        print("REAL ROBOT PERFORMANCE REPORT (Internal GT)")
        print("="*50)
        
        print("1. Velocity Tracking (GT: Time-variant cmd_vel)")
        print(f"   Vx RMSE: {metrics['rmse_vx']:.4f} m/s")
        print(f"   Vy RMSE: {metrics['rmse_vy']:.4f} m/s")
        print(f"   Wz RMSE: {metrics['rmse_wz']:.4f} rad/s")
        
        print("\n2. Stability (GT: 0.0 rad)")
        print(f"   Roll  - Mean (Bias): {metrics['roll_mean']:.4f}, Std: {metrics['roll_std']:.4f}")
        print(f"   Pitch - Mean (Bias): {metrics['pitch_mean']:.4f}, Std: {metrics['pitch_std']:.4f}")
        if abs(metrics['pitch_mean']) > 0.03:
            print(f"   [WARN] Pitch bias > 0.03 rad detected. Calibration recommended.")
            
        print("\n3. Energy Efficiency (Baseline: 53.8 W)")
        print(f"   Avg Power: {metrics['avg_power']:.2f} W (+/- {metrics['std_power']:.2f})")
        print(f"   Ratio to Baseline: {metrics['power_ratio']:.2f}x")
        
        print("\n4. Control Smoothness (Jitter)")
        print(f"   Torque Jitter: {metrics['torque_jitter']:.4f} Nm/step")
        print(f"   (Lower is better. High values indicate vibration/noise)")
        print("="*50 + "\n")

def main():
    parser = argparse.ArgumentParser(description="Real Robot Performance Evaluator")
    parser.add_argument("--real_log", type=str, required=True, help="Path to Real-world log (.csv or .mcap)")
    
    args = parser.parse_args()
    
    # Load Real Data
    if args.real_log.endswith('.csv'):
        real_loader = CsvLogLoader(args.real_log)
    elif args.real_log.endswith('.mcap'):
        real_loader = RosBagLoader(args.real_log)
    else:
        print(f"[ERROR] Unsupported file format: {args.real_log}. Use .csv or .mcap")
        return

    try:
        real_data = real_loader.load()
    except Exception as e:
        print(f"[ERROR] Failed to load Real data: {e}")
        return

    # Evaluate Real Performance (Internal GT)
    real_evaluator = RealPerformanceEvaluator(real_data)
    real_metrics = real_evaluator.evaluate()
    real_evaluator.generate_report(real_metrics)

if __name__ == "__main__":
    main()
