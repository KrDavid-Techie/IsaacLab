import argparse
import os
import sys
import csv
import numpy as np
from datetime import datetime

# Optional dependencies
try:
    from mcap.reader import make_reader
    from mcap_ros2.decoder import DecoderFactory
except ImportError:
    pass # Handled in main or usage

class RobustVelocityEstimator:
    """
    Robust Velocity Estimator using Sensor Fusion (Leg Odometry + IMU)
    """
    def __init__(self):
        self.alpha = 0.95  # Filter weight
        self.dt = 0.002    # Sample time (approx)

    def compute_velocity(self, data):
        """Takes a data dictionary and returns an estimated velocity (vx) array."""
        print("[INFO] Computing velocity from Sensor Fusion (Leg Odom + IMU)...")
        
        # Extract data
        dof_vel = data["dof_vel"]
        dof_pos = data["dof_pos"]
        
        # Robust key access
        if "foot_force" in data:
            foot_force = data["foot_force"]
        else:
            foot_force = np.zeros((len(dof_vel), 4))

        if "dof_torque" in data:
            dof_torque = data["dof_torque"]
        else:
            dof_torque = None

        if "base_acc" in data:
            acc_local = data["base_acc"]
        elif "base_acc_0" in data:
            acc_local = np.array([data[f"base_acc_{i}"] for i in range(3)]).T
        else:
            acc_local = np.zeros((len(dof_vel), 3))
            
        if "base_quat" in data:
            quat = data["base_quat"]
        elif "base_quat_0" in data:
            quat = np.array([data[f"base_quat_{i}"] for i in range(4)]).T
        else:
            quat = np.array([[1,0,0,0]]*len(dof_vel))
        
        # 기구학 파라미터 (Go2)
        L2, L3 = 0.213, 0.213 
        
        estimated_vx = []
        current_v = 0.0
        
        for i in range(len(dof_vel)):
            # 1. Leg Odometry (지면에 닿은 다리 기준 속도 역산)
            leg_vs = []
            for leg in range(4):
                is_contact = False
                # Force Check
                if foot_force[i, leg] > 15.0: 
                    is_contact = True
                
                # Torque Check (Fallback)
                if dof_torque is not None:
                    idx = leg * 3
                    # Thigh + Calf torque sum
                    t_sum = abs(dof_torque[i, idx+1]) + abs(dof_torque[i, idx+2])
                    if t_sum > 5.0:
                        is_contact = True

                if is_contact:
                    # 각 다리의 Hip, Thigh, Calf 인덱스
                    idx = leg * 3
                    q_thigh = dof_pos[i, idx+1]
                    q_calf = dof_pos[i, idx+2]
                    dq_thigh = dof_vel[i, idx+1]
                    dq_calf = dof_vel[i, idx+2]
                    
                    # Forward Kinematics Derivative (v_x only)
                    # v_foot = J * dq -> v_body = -v_foot
                    v_foot_x = (L2 * np.cos(q_thigh) * dq_thigh + 
                                L3 * np.cos(q_thigh + q_calf) * (dq_thigh + dq_calf))
                    leg_vs.append(-v_foot_x)
            
            v_leg = np.mean(leg_vs) if leg_vs else 0.0
            
            # 2. IMU Acceleration (World Frame 변환 생략하고 x축 근사 사용)
            # 엄밀하게는 쿼터니언 회전 필요하지만, 평지 주행 가정 시 ax 그대로 사용 가능
            ax = acc_local[i, 0]
            
            # 3. Sensor Fusion (Complementary)
            if not leg_vs: # 공중
                v_pred = current_v + ax * self.dt
                current_v = v_pred * 0.98 # Decay
            else:
                v_pred = current_v + ax * self.dt
                current_v = self.alpha * v_pred + (1 - self.alpha) * v_leg
                
            estimated_vx.append(current_v)
            
        return np.array(estimated_vx) 


class CsvLogLoader:
    """Loads real-world robot logs from CSV files generated by logger_node.py."""
    
    def __init__(self, file_path):
        self.file_path = file_path

    def load(self):
        if not os.path.exists(self.file_path):
            raise FileNotFoundError(f"CSV log file not found: {self.file_path}")
            
        print(f"[INFO] Parsing CSV Log: {self.file_path}")
        
        data = {
            "timestamp": [],
            "base_lin_vel": [],
            "base_ang_vel": [],
            "dof_pos": [],
            "dof_vel": [],
            "dof_torque": [],
            "command_vel": [],
            "bms_power": [],
            "rpy": [],
            "foot_force": [],
            "base_acc": [],
            "base_quat": []
        }
        
        with open(self.file_path, 'r') as f:
            reader = csv.DictReader(f)
            for row in reader:
                try:
                    # Timestamp
                    data["timestamp"].append(float(row['timestamp']))
                    
                    # Command Velocity [vx, vy, wz]
                    data["command_vel"].append([
                        float(row['cmd_vel_0']), 
                        float(row['cmd_vel_1']), 
                        float(row['cmd_vel_2'])
                    ])
                    
                    # Base Linear Velocity [vx, vy, vz]
                    data["base_lin_vel"].append([
                        float(row['base_lin_vel_0']), 
                        float(row['base_lin_vel_1']), 
                        float(row['base_lin_vel_2'])
                    ])

                    # Base Angular Velocity [wx, wy, wz]
                    if 'base_ang_vel_0' in row:
                        data["base_ang_vel"].append([
                            float(row['base_ang_vel_0']), 
                            float(row['base_ang_vel_1']), 
                            float(row['base_ang_vel_2'])
                        ])
                    else:
                        data["base_ang_vel"].append([0.0, 0.0, 0.0])
                    
                    # Joint States (12 DOF)
                    data["dof_pos"].append([float(row[f'dof_pos_{i}']) for i in range(12)])
                    data["dof_vel"].append([float(row[f'dof_vel_{i}']) for i in range(12)])
                    data["dof_torque"].append([float(row[f'dof_torque_{i}']) for i in range(12)])
                    
                    # RPY
                    if 'rpy_roll' in row:
                        data["rpy"].append([
                            float(row['rpy_roll']),
                            float(row['rpy_pitch']),
                            float(row['rpy_yaw'])
                        ])
                    else:
                        data["rpy"].append([0.0, 0.0, 0.0])

                    # Foot Force
                    if 'foot_force_0' in row:
                        data["foot_force"].append([float(row[f'foot_force_{i}']) for i in range(4)])
                    else:
                        data["foot_force"].append([0.0]*4)

                    # IMU Acc
                    if 'imu_acc_0' in row:
                        data["base_acc"].append([float(row[f'imu_acc_{i}']) for i in range(3)])
                    elif 'base_acc_0' in row:
                        data["base_acc"].append([float(row[f'base_acc_{i}']) for i in range(3)])
                    else:
                        data["base_acc"].append([0.0]*3)

                    # IMU Quat
                    if 'imu_quat_0' in row:
                        data["base_quat"].append([float(row[f'imu_quat_{i}']) for i in range(4)])
                    elif 'base_quat_0' in row:
                        data["base_quat"].append([float(row[f'base_quat_{i}']) for i in range(4)])
                    else:
                        data["base_quat"].append([1.0, 0.0, 0.0, 0.0])

                    # BMS Power (if available)
                    if 'power' in row:
                        data["bms_power"].append(float(row['power']))
                    elif 'bms_voltage' in row and 'bms_current' in row:
                        data["bms_power"].append(float(row['bms_voltage']) * float(row['bms_current']))
                    else:
                        data["bms_power"].append(0.0)
                        
                except ValueError:
                    continue # Skip malformed rows

        # Convert to numpy arrays
        for key in data:
            data[key] = np.array(data[key])
            
        print(f"[INFO] Loaded {len(data['timestamp'])} frames from CSV Log.")
        return data


class RosBagLoader:
    """Loads real-world robot logs from ROS2 MCAP files."""
    
    def __init__(self, bag_path):
        self.bag_path = bag_path

    def load(self):
        """Parses standard ROS2 topics from the bag file."""
        if not os.path.exists(self.bag_path):
            raise FileNotFoundError(f"Bag file not found: {self.bag_path}")

        print(f"[INFO] Parsing ROS Bag: {self.bag_path}")
        
        data = {
            "timestamp": [],
            "base_lin_vel": [],
            "dof_pos": [],
            "dof_vel": [],
            "dof_torque": [],
            "command_vel": []
        }
        
        # Temporary storage for synchronization
        # We assume messages are written in blocks with same timestamp or close enough
        # We trigger a data point when we receive JointState
        last_cmd = [0.0, 0.0, 0.0] # vx, vy, wz
        last_odom_vel = [0.0, 0.0, 0.0] # vx, vy, vz
        
        with open(self.bag_path, "rb") as f:
            reader = make_reader(f, decoder_factories=[DecoderFactory()])
            
            start_time = None
            
            # Topics to read
            topics = ["/joint_states", "/odom", "/cmd_vel"]
            
            for schema, channel, message in reader.iter_decoded_messages(topics=topics):
                topic = channel.topic
                
                # 1. Command Velocity
                if topic == "/cmd_vel":
                    last_cmd = [message.linear.x, message.linear.y, message.angular.z]
                    
                # 2. Odometry (Base Velocity)
                elif topic == "/odom":
                    last_odom_vel = [
                        message.twist.twist.linear.x,
                        message.twist.twist.linear.y,
                        message.twist.twist.linear.z
                    ]
                    
                # 3. Joint States (Trigger)
                elif topic == "/joint_states":
                    # Extract timestamp
                    t = message.header.stamp.sec + message.header.stamp.nanosec * 1e-9
                    
                    if start_time is None:
                        start_time = t
                    
                    # Joint Data
                    # Ensure order is correct (FL, FR, RL, RR) or just take as is if logger preserves order
                    # go2_logger writes in 0-11 order
                    q = message.position
                    dq = message.velocity
                    tau = message.effort
                    
                    if len(q) != 12:
                        continue

                    data["timestamp"].append(t - start_time)
                    data["dof_pos"].append(q)
                    data["dof_vel"].append(dq)
                    data["dof_torque"].append(tau)
                    data["base_lin_vel"].append(last_odom_vel)
                    data["command_vel"].append(last_cmd)

        # Convert to numpy arrays
        for key in data:
            data[key] = np.array(data[key])
            
        print(f"[INFO] Loaded {len(data['timestamp'])} frames from Real Log.")
        return data


class RealPerformanceEvaluator:
    """Evaluates Real-world robot performance based on internal Ground Truth."""
    
    def __init__(self, real_data):
        self.real = real_data

    def evaluate(self):
        print("[INFO] Evaluating Real Robot Performance...")
        
        # ---------------------------------------------------------
        # [수정] Velocity Source Selection Logic
        # ---------------------------------------------------------
        # 우선순위 1: High Level Velocity (Sensor/SportMode)
        real_vel_vec = self.real["base_lin_vel"]
        speed_raw = np.linalg.norm(real_vel_vec[:, :2], axis=1)
        mean_speed = np.mean(speed_raw)
        
        velocity_source = "Unknown"
        final_speed_data = speed_raw
        
        if mean_speed > 0.01:
            velocity_source = "High Level (Sensor)"
            final_speed_data = speed_raw
            
        else:
            # 우선순위 2: Logged Estimated Velocity (est_vx 컬럼이 있는 경우)
            if "est_vx" in self.real:
                velocity_source = "Logged Estimate (Online)"
                est_vx = self.real["est_vx"]
                est_vy = self.real["est_vy"]
                final_speed_data = np.sqrt(est_vx**2 + est_vy**2)
                
            # 우선순위 3: Post-Calculated Estimate (직접 계산)
            else:
                velocity_source = "Computed Estimate (Offline)"
                estimator = RobustVelocityEstimator()
                # self.real 딕셔너리를 넘겨주기 위해 numpy array로 변환된 상태인지 확인 필요
                # Loader에서 이미 numpy로 변환했으므로 그대로 전달
                est_vx = estimator.compute_velocity(self.real)
                final_speed_data = np.abs(est_vx) # 전진 속도 크기

        print(f"[INFO] Selected Velocity Source: {velocity_source}")
        # ---------------------------------------------------------

        # 1. Velocity Tracking (GT: cmd_vel)
        # cmd_vel: [vx, vy, wz]
        # base_lin_vel: [vx, vy, vz]
        # base_ang_vel: [wx, wy, wz]
        
        cmd_vx = self.real["command_vel"][:, 0]
        cmd_vy = self.real["command_vel"][:, 1]
        cmd_wz = self.real["command_vel"][:, 2]
        
        real_vx = self.real["base_lin_vel"][:, 0]
        real_vy = self.real["base_lin_vel"][:, 1]
        
        # Check if base_ang_vel exists and has data
        if "base_ang_vel" in self.real and len(self.real["base_ang_vel"]) > 0:
            real_wz = self.real["base_ang_vel"][:, 2]
        else:
            real_wz = np.zeros_like(cmd_wz) # Fallback if not available
            
        # RMSE Calculation
        rmse_vx = np.sqrt(np.mean((cmd_vx - real_vx)**2))
        rmse_vy = np.sqrt(np.mean((cmd_vy - real_vy)**2))
        rmse_wz = np.sqrt(np.mean((cmd_wz - real_wz)**2))
        
        # 2. Stability (GT: 0.0 rad for Roll/Pitch)
        # RPY: [roll, pitch, yaw]
        if "rpy" in self.real and len(self.real["rpy"]) > 0:
            roll = self.real["rpy"][:, 0]
            pitch = self.real["rpy"][:, 1]
            
            roll_mean = np.mean(roll)
            roll_std = np.std(roll)
            pitch_mean = np.mean(pitch)
            pitch_std = np.std(pitch)
        else:
            roll_mean, roll_std = 0.0, 0.0
            pitch_mean, pitch_std = 0.0, 0.0
            
        # 3. Energy Efficiency (CoT with Selected Speed)
        BASELINE_POWER = 53.8
        ROBOT_MASS = 15.0
        GRAVITY = 9.81
        
        avg_power = 0.0
        std_power = 0.0
        cot_val = 0.0
        
        if "bms_power" in self.real and len(self.real["bms_power"]) > 0:
            # Masking: Command가 있는 구간만
            cmd_mag = np.linalg.norm(self.real["command_vel"][:, :2], axis=1)
            is_active = cmd_mag > 0.01
            
            if np.sum(is_active) > 0:
                active_power = self.real["bms_power"][is_active]
                active_speed = final_speed_data[is_active] # <--- 선택된 속도 데이터 사용
                
                avg_power = np.mean(active_power)
                std_power = np.std(active_power)
                
                # [Modified] CoT Calculation: Filter for actual walking (speed > 0.2 m/s)
                # to exclude standing/stuck phases which inflate CoT.
                is_walking = active_speed > 0.2
                if np.sum(is_walking) > 10: # Minimum frames to be valid
                    walking_power = active_power[is_walking]
                    walking_speed = active_speed[is_walking]
                    cot_val = np.mean(walking_power) / (ROBOT_MASS * GRAVITY * np.mean(walking_speed))
                    print(f"[INFO] CoT calculated using {np.sum(is_walking)} frames (Speed > 0.2 m/s)")
                else:
                    # Fallback to average if never reached 0.2 m/s
                    avg_speed_val = np.mean(active_speed)
                    if avg_speed_val > 0.01:
                        cot_val = avg_power / (ROBOT_MASS * GRAVITY * avg_speed_val)
                    else:
                        cot_val = 0.0
                    
        cot_ratio = avg_power / BASELINE_POWER if BASELINE_POWER > 0 else 0.0
            
        # 4. Smoothness (Jitter)
        # We define Jitter as the mean absolute change in torque between time steps.
        # Lower is smoother.
        if "dof_torque" in self.real and len(self.real["dof_torque"]) > 0:
            # Calculate diff along time axis (axis 0)
            torque_diff = np.diff(self.real["dof_torque"], axis=0)
            # Mean of absolute differences across all joints and time steps
            torque_jitter = np.mean(np.abs(torque_diff))
        else:
            torque_jitter = 0.0

        return {
            "rmse_vx": rmse_vx,
            "rmse_vy": rmse_vy,
            "rmse_wz": rmse_wz,
            "roll_mean": roll_mean,
            "roll_std": roll_std,
            "pitch_mean": pitch_mean,
            "pitch_std": pitch_std,
            "avg_power": avg_power,
            "std_power": std_power,
            "power_ratio": cot_ratio,
            "cot": cot_val,
            "vel_source": velocity_source,
            "torque_jitter": torque_jitter
        }

    def generate_report(self, metrics):
        print("\n" + "="*50)
        print("REAL ROBOT PERFORMANCE REPORT (Internal GT)")
        print("="*50)
        print("1. Velocity Tracking (GT: Time-variant cmd_vel)")
        print(f"   Vx RMSE: {metrics['rmse_vx']:.4f} m/s")
        print(f"   Vy RMSE: {metrics['rmse_vy']:.4f} m/s")
        print(f"   Wz RMSE: {metrics['rmse_wz']:.4f} rad/s")
        print("\n2. Stability (GT: 0.0 rad)")
        print(f"   Roll  - Mean (Bias): {metrics['roll_mean']:.4f}, Std: {metrics['roll_std']:.4f}")
        print(f"   Pitch - Mean (Bias): {metrics['pitch_mean']:.4f}, Std: {metrics['pitch_std']:.4f}")
        if abs(metrics['pitch_mean']) > 0.03:
            print(f"   [WARN] Pitch bias > 0.03 rad detected. Calibration recommended.")
        print("\n3. Energy Efficiency (Baseline: 53.8 W)")
        print(f"   Avg Power: {metrics['avg_power']:.2f} W (+/- {metrics['std_power']:.2f})")
        print(f"   Ratio to Baseline: {metrics['power_ratio']:.2f}x")
        print(f"   Velocity Source: {metrics.get('vel_source', 'Unknown')}")
        print(f"   Calculated CoT:  {metrics.get('cot', 0.0):.4f}")
        print("\n4. Control Smoothness (Jitter)")
        print(f"   Torque Jitter: {metrics['torque_jitter']:.4f} Nm/step")
        print(f"   (Lower is better. High values indicate vibration/noise)")
        print("="*50 + "\n")

        # --- CSV 저장 ---
        today_str = datetime.now().strftime('%Y-%m-%d')
        csv_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'sim2real_reports')
        os.makedirs(csv_dir, exist_ok=True)
        csv_path = os.path.join(csv_dir, f"real_eval_report_{today_str}.csv")
        file_exists = os.path.isfile(csv_path)
        fieldnames = [
            'Date', 'Vx_RMSE', 'Vy_RMSE', 'Wz_RMSE',
            'Roll_Mean', 'Roll_Std', 'Pitch_Mean', 'Pitch_Std',
            'Avg_Power', 'Std_Power', 'Power_Ratio', 'CoT', 'Velocity_Source', 'Torque_Jitter'
        ]
        row = {
            'Date': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            'Vx_RMSE': f"{metrics['rmse_vx']:.4f}",
            'Vy_RMSE': f"{metrics['rmse_vy']:.4f}",
            'Wz_RMSE': f"{metrics['rmse_wz']:.4f}",
            'Roll_Mean': f"{metrics['roll_mean']:.4f}",
            'Roll_Std': f"{metrics['roll_std']:.4f}",
            'Pitch_Mean': f"{metrics['pitch_mean']:.4f}",
            'Pitch_Std': f"{metrics['pitch_std']:.4f}",
            'Avg_Power': f"{metrics['avg_power']:.2f}",
            'Std_Power': f"{metrics['std_power']:.2f}",
            'Power_Ratio': f"{metrics['power_ratio']:.2f}",
            'CoT': f"{metrics.get('cot', 0.0):.4f}",
            'Velocity_Source': metrics.get('vel_source', 'Unknown'),
            'Torque_Jitter': f"{metrics['torque_jitter']:.4f}"
        }
        import csv
        with open(csv_path, 'a', newline='') as csvfile:
            writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
            if not file_exists:
                writer.writeheader()
            writer.writerow(row)
        print(f"[INFO] Report appended to {csv_path}")

def main():
    parser = argparse.ArgumentParser(description="Real Robot Performance Evaluator")
    parser.add_argument("--real_log", type=str, required=True, help="Path to Real-world log (.csv or .mcap)")
    
    args = parser.parse_args()
    
    # Load Real Data
    if args.real_log.endswith('.csv'):
        real_loader = CsvLogLoader(args.real_log)
    elif args.real_log.endswith('.mcap'):
        real_loader = RosBagLoader(args.real_log)
    else:
        print(f"[ERROR] Unsupported file format: {args.real_log}. Use .csv or .mcap")
        return

    try:
        real_data = real_loader.load()
    except Exception as e:
        print(f"[ERROR] Failed to load Real data: {e}")
        return

    # Evaluate Real Performance (Internal GT)
    real_evaluator = RealPerformanceEvaluator(real_data)
    real_metrics = real_evaluator.evaluate()
    real_evaluator.generate_report(real_metrics)

if __name__ == "__main__":
    main()
